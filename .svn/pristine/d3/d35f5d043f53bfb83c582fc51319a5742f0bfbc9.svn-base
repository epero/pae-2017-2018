package util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Logger;
import biz.entreprise.EntrepriseDto;
import biz.factory.BizFactory;
import biz.pdc.PersonneContactDto;
import exceptions.FatalException;
import util.AppContext.DependanceInjection;

public class DaoUtil {

  @DependanceInjection
  private BizFactory factory;

  /**
   * Méthode qui set un nombre arbitraire d'objets sur un PreparedStatement. La méthode itère sur
   * chaque objet passé en paramètre et appele la méthode setObject() sur le PreparedStatement.
   * 
   * @param ps un PreparedStatement déjà créé
   * @param objects un nombre arbitraire d'objets de type Object contenant l'input de l'utilisateur
   */
  public void setPreparedStatement(PreparedStatement ps, Object... objects) {
    try {
      // le premier indice est à 1
      for (int i = 1; i <= objects.length; i++) {
        ps.setObject(i, objects[i - 1]);
      }
    } catch (SQLException ex) {
      Logger.getLogger("stagifyLogger")
          .severe("Erreur lors du prepareStatement\n\t" + Util.stackTraceToString(ex));
      throw new FatalException("Erreur lors de la customisation du preparedStatement");
    }
  }



  /**
   * Méthode qui : * vérifie s'il existe au moins un tuple pour un ResultSet et renvoie false le cas
   * contraire; * parcourt chaque tuple de ce ResultSet grace à un objet metadata. Pour chaque
   * tuple, la méthode : * récupère et renomme le nom de la colonne (un champ dans la BD) * recupère
   * par introspection les méthodes de la classe instanciée passée en paramètre. Pour chaque méthode
   * propres à l'instance, la méthode : * vérifie qu'il s'agit d'un setter et qu'il correspond au
   * nom de la colonne * set sur l'instance la valeur de la colonne du tuple en cours.
   * 
   * @param classe une classe à instancier sur laquelle on invoque ses setters
   * @param rs un ResultSet, résultat d'un preparedStatement.executeQuery()
   * @return une liste de Object remplie ou vide
   */
  public List<Object> setResultSet(Class<?> classe, ResultSet rs) {
    try {
      ResultSetMetaData rsmd = rs.getMetaData(); // objet metadata
      List<Object> liste = new ArrayList<Object>();
      List<Method> setters = new ArrayList<Method>();
      if (rs.next()) {
        Object instance = classe.newInstance();
        for (Method method : classe.getDeclaredMethods()) {
          if (method.getName().startsWith("set")) {
            setters.add(method);
          }
        }
        do {
          instance = classe.newInstance();
          for (int i = 1; i <= rsmd.getColumnCount(); i++) {
            String nomColonne = rsmd.getColumnName(i).replace("_", "").toLowerCase();
            for (Method setter : setters) {
              if (nomColonne.equals(setter.getName().toLowerCase().substring(3))) {
                if (rs.getObject(i) == null) {
                  // passer à l'itération suivante
                  continue;
                }
                if (rs.getObject(i).getClass().getName().equals("java.sql.Timestamp")) {
                  Timestamp ts = (Timestamp) rs.getObject(i);
                  setter.invoke(instance, ts.toLocalDateTime().toLocalDate());
                } else {
                  setter.invoke(instance, rs.getObject(i));
                }
              }
            }
          }
          liste.add(instance);
          // System.out.println(instance.toString());
        } while (rs.next());
      }
      return liste;

    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException
        | SQLException | InstantiationException ex) {
      Logger.getLogger("stagifyLogger")
          .severe("Accès à la DB impossible\n\t" + Util.stackTraceToString(ex));
      throw new FatalException("Accès à la DB impossible");
    }
  }


  /**
   * Rempli un EntrepriseDto avec les informations données.
   * 
   * @param idEntreprise l'id de l'entreprise
   * @param denomination la dénomination de l'entreprise
   * @param adresse l'adresse de l'entreprise
   * @param numero le numéro de l'entreprise
   * @param boite la boite de l'entreprise
   * @param codePostal le code postal de l'entreprise
   * @param ville la ville de l'entreprise
   * @param email l'email de l'entreprise
   * @param tel le numéro de téléphone de l'entreprise
   * @param estBlackListe le fait que l'entreprise soit blacklisté ou non
   * @return un objet EntrepriseDto rempli
   */
  public EntrepriseDto remplirEntreprise(int idEntreprise, String denomination, String adresse,
      String numero, String boite, String codePostal, String ville, String email, String tel,
      boolean estBlackListe) {
    // TODO Rajouter le num_version et modifier les méthodes qui en dépendent ?
    EntrepriseDto entreprise = factory.getEntrepriseVide();
    entreprise.setIdEntreprise(idEntreprise);
    entreprise.setDenomination(denomination);
    entreprise.setAdresse(adresse);
    entreprise.setNumero(numero);
    entreprise.setBoite(boite);
    entreprise.setCodePostal(codePostal);
    entreprise.setVille(ville);
    entreprise.setEmail(email);
    entreprise.setTel(tel);
    entreprise.setEstBlackListe(estBlackListe);
    return entreprise;
  }


  /**
   * Rempli un PersonneContactDto avec les informations données.
   * 
   * @param idPersonneContact l'id de la personne de contact
   * @param nom le nom de la personne de contact
   * @param prenom le prénom de la personne de contact
   * @param tel le numéro de téléphone de la personne de contact
   * @param email l'email de la personne de contact
   * @param entreprise l'entreprise de la personne de contact
   * @return un objet PersonneContactDto rempli
   */
  public PersonneContactDto remplirPersonneContact(Object idPersonneContact, String nom,
      String prenom, String tel, String email, Object entreprise) {
    // TODO Rajouter le num_version et modifier les méthodes qui en dépendent ?
    PersonneContactDto personneContact = factory.getPersonneContactVide();
    // si id == null alors il n y a pas de personne de contact et on renvoi null
    if (idPersonneContact == null) {
      return null;
    }
    if (entreprise == null) {
      throw new FatalException(
          "Erreur de FK entreprise dans la table personnes de contact de la DB");
    }
    personneContact.setIdPersonneContact((int) idPersonneContact);
    personneContact.setNom(nom);
    personneContact.setPrenom(prenom);
    personneContact.setTel(tel);
    personneContact.setEmail(email);
    personneContact.setEntreprise((int) entreprise);
    return personneContact;
  }


}
