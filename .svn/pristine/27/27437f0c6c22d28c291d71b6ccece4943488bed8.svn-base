package util;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Properties;
import exceptions.FatalException;

public class AppContext {

  private HashMap<Class<?>, Object> instances = new HashMap<Class<?>, Object>();

  private Properties properties;


  @Retention(RetentionPolicy.RUNTIME)
  public @interface DependanceInjection {
  }

  /**
   * Constructeur.
   */
  public AppContext() {
    try {
      instances.put(Class.forName("util.AppContext"), this);
    } catch (ClassNotFoundException ex) {
      // TODO Auto-generated catch block
      ex.printStackTrace();
      System.out.println("Impossible de charger AppContext");
      throw new FatalException();
    }
  }

  /**
   * Crée une nouvelle instance de l'objet en paramètre via l'injection dépendance.
   * 
   * @param objet à instancier
   */
  public void recurDepInj(Object objet) {
    if (properties == null) {
      System.out.println("Le fichier properties n'a pas encore été chargé");
      return;
    }
    for (Field field : objet.getClass().getDeclaredFields()) {
      if (field.isAnnotationPresent(DependanceInjection.class)) {
        Object ob;
        Class<?> cl;
        try {
          cl = Class.forName(properties.getProperty(field.getType().getCanonicalName()));
        } catch (ClassNotFoundException e1) {
          System.out.println("Classe inéxistante");
          e1.printStackTrace();
          throw new FatalException();
        }
        if (!instances.containsKey(cl)) {
          System.out.println(field.getType().getCanonicalName());
          Constructor constructor;
          try {
            constructor = cl.getDeclaredConstructor();
          } catch (NoSuchMethodException | SecurityException ex) {
            System.out.println("Constructeur inéxistant");
            ex.printStackTrace();
            throw new FatalException();
          }
          constructor.setAccessible(true);
          try {
            ob = constructor.newInstance();
          } catch (InstantiationException | IllegalAccessException | IllegalArgumentException
              | InvocationTargetException ex) {
            System.out.println("Initialisation impossible");
            ex.printStackTrace();
            throw new FatalException();
          }
          instances.put(cl, ob);
          // appel récursif
          recurDepInj(ob);
        }

        field.setAccessible(true);
        try {
          field.set(objet, instances.get(cl));
        } catch (IllegalArgumentException | IllegalAccessException ex) {
          ex.printStackTrace();
          throw new FatalException();
        }
      }
    }
  }


  /**
   * Charge le fichier Properties passé en paramètre.
   * 
   * @param fichier Le fichier où se trouve les Properties
   */
  public void loadProps(String fichier) {
    if (fichier == null) {
      System.out.println("run du fichier par defaut");
      fichier = "dev.properties";
    }
    properties = new Properties();

    try (FileInputStream file = new FileInputStream("conf/" + fichier)) {
      properties.load(file);
    } catch (FileNotFoundException ex) {
      System.out.println("Fichier properties introuvable");
      ex.printStackTrace();
      throw new FatalException();
    } catch (IOException ex) {
      System.out.println("Impossible de lire le fichier");
      ex.printStackTrace();
      throw new FatalException();
    }
  }


  /**
   * Cherche la clé associée à la chaîne passée en paramètre.
   * 
   * @param key la chaîne représentant la clé
   * @return la clé correspondante dans le fichier Properties
   */
  public String getValueProp(String key) {
    if (properties == null) {
      System.out.println("Le fichier properties n'a pas encore été chargé");
      return null;
    }
    Util.checkString(key);
    return properties.getProperty(key);
  }
}

