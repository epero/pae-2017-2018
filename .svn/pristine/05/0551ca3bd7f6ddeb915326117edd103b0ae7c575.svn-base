package dal.services;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import exceptions.FatalException;
import util.AppContext;
import util.AppContext.DependanceInjection;

class DalServicesImpl implements DalServices, DalBackendServices {

  @DependanceInjection
  private AppContext appContext;

  private Connection conn = null;
  private int compteurTransaction = 0;

  private void connect() {
    if (conn != null)
      return;
    try {
      Class.forName(appContext.getValueProp("driverClassName"));
    } catch (ClassNotFoundException ex) {
      System.out.println("Driver Postgresql manquant !");
      throw new FatalException("Driver Postgresql manquant !");
    }

    try {
      conn = DriverManager.getConnection(appContext.getValueProp("url"),
          appContext.getValueProp("ndcDB"), appContext.getValueProp("mdpDB"));
    } catch (SQLException ex) {
      System.out.println("Erreur de connexion à la base de données");
      throw new FatalException("Erreur de connexion à la base de données");
    }
  }

  /**
   * Envoie de la requête en PreparedStatement à la base de données.
   * 
   * @param query Requête envoyée à la base de données
   * @return Une query préparée avec la string passée en paramètre
   * 
   */
  public PreparedStatement getPreparedStatement(String query) {
    connect();
    if (conn != null) {
      // probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau
      // PreparedStatement --> couteux?
      // -> Bonne pratique avec PreparedStatement : les créer une seule fois (au démarrage ou au
      // premier usage)
      PreparedStatement ps = null;
      try {
        ps = conn.prepareStatement(query);
      } catch (SQLException ex) {
        System.out.println("Erreur SQL");
        ex.printStackTrace();
        throw new FatalException();
      }
      return ps;
    }
    return null;
  }

  @Override
  public void startTransaction() {
    connect();
    if (compteurTransaction == 0) {
      try {
        conn.setAutoCommit(false);
      } catch (SQLException e) {
        e.printStackTrace();
        System.err.println("Erreur dans la méthode startTransaction()");
        throw new FatalException("Erreur base de données");
      }
    }
    compteurTransaction++;

  }

  @Override
  public void commitTransaction() {
    if (compteurTransaction == 0) {
      System.err
          .println("Erreur dans la méthode commitTransaction() : le compteurTransaction == 0");
      throw new FatalException("Erreur base de données");
    }
    if (compteurTransaction > 0) {
      compteurTransaction--;
    }
    if (compteurTransaction == 0) {
      try {
        conn.commit();
        conn.setAutoCommit(true);
      } catch (SQLException e) {
        e.printStackTrace();
        System.err.println("Erreur dans la méthode commitTransaction()");
        rollback();
      }
    }
  }

  @Override
  public void rollback() {
    // réinitialiser le compteur
    compteurTransaction = 0;
    try {
      conn.rollback();
    } catch (SQLException e) {
      e.printStackTrace();
      System.err.println("Erreur dans la méthode rollback()");
      throw new FatalException("Erreur base de données");
    }
  }
}
