package dal.services;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Logger;
import javax.sql.DataSource;
import org.apache.commons.dbcp2.ConnectionFactory;
import org.apache.commons.dbcp2.DriverManagerConnectionFactory;
import org.apache.commons.dbcp2.PoolableConnection;
import org.apache.commons.dbcp2.PoolableConnectionFactory;
import org.apache.commons.dbcp2.PoolingDataSource;
import org.apache.commons.pool2.ObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPool;
import exceptions.FatalException;
import util.AppContext;
import util.AppContext.DependanceInjection;

class DalServicesImpl implements DalServices, DalBackendServices {

  @DependanceInjection
  private AppContext appContext;

  // private Connection conn = null;

  private ThreadLocal<Connection> connThrLoc = new ThreadLocal<>();
  // private ThreadLocal<Integer> comptTransThrLoc = new ThreadLocal<>();
  private DataSource dataSource = null;
  // private int compteurTransaction = 0;

  private void connect() {
    if (dataSource == null) {
      setUpDataSource();
    }
    if (connThrLoc.get() == null) {
      try {
        connThrLoc.set(dataSource.getConnection());
        // comptTransThrLoc.set(0);
      } catch (SQLException ex) {
        throw new FatalException("Erreur de connexion à la base de données");
      }
    }
  }

  // TODO verifier si setAutoCommit() puisse lancer une exception
  // si oui, il faut s'assurer qu'on puisse .close()
  private void freeConnection() {
    try {
      if (!connThrLoc.get().isClosed()) {
        try {
          connThrLoc.get().setAutoCommit(true);
        } catch (SQLException ex) {
          // ex.printStackTrace();
        }
        connThrLoc.get().close();
      }
    } catch (SQLException ex) {
      // connThrLoc.remove();
      throw new FatalException("Erreur de connexion à la base de données");
    } finally {
      connThrLoc.remove();
    }
    // connThrLoc.remove();

    // comptTransThrLoc.set(0);
  }

  @Override
  public void startTransaction() {
    connect();
    try {
      connThrLoc.get().setAutoCommit(false);
    } catch (SQLException ex) {
      freeConnection();
      throw new FatalException("Erreur dans la méthode startTransaction()");
    }

  }

  public void commitTransaction() {

    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    try {
      connThrLoc.get().commit();
      freeConnection();
    } catch (SQLException ex) {
      Logger.getLogger("stagifyLogger").severe("Erreur SQL: " + ex.getStackTrace());
      rollback();
      // Faut-il lancer une fatalException? si oui il faut enlever le log
    }

  }

  @Override
  public void rollback() {

    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    try {
      connThrLoc.get().rollback();
    } catch (SQLException ex) {
      freeConnection();
      throw new FatalException("Erreur base de données rollback()");
    } finally {
      // freeConnection();
    }
  }

  public PreparedStatement getPreparedStatement(String query) {
    // TODO probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau
    // PreparedStatement --> couteux?
    // -> Bonne pratique avec PreparedStatement : les créer une seule fois (au démarrage ou au
    // premier usage)
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    PreparedStatement ps = null;
    try {
      ps = connThrLoc.get().prepareStatement(query);
    } catch (SQLException ex) {
      throw new FatalException("Impossible de récuperer le preparedStatement");
    }
    return ps;
  }

  public PreparedStatement getPreparedStatementForInsert(String query) {
    // TODO probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau
    // PreparedStatement --> couteux?
    // -> Bonne pratique avec PreparedStatement : les créer une seule fois (au démarrage ou au
    // premier usage)
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    PreparedStatement ps = null;
    try {
      ps = connThrLoc.get().prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
    } catch (SQLException ex) {
      throw new FatalException("Impossible de récuperer le preparedStatement");
    }
    return ps;
  }

  private void setUpDataSource() {
    if (dataSource != null) {
      return;
    }
    try {
      Class.forName(appContext.getValueProp("driverClassName"));
    } catch (ClassNotFoundException ex) {
      throw new FatalException("Driver Postgresql manquant !");
    }

    ConnectionFactory connectionFactory =
        new DriverManagerConnectionFactory(appContext.getValueProp("url"),
            appContext.getValueProp("ndcDB"), appContext.getValueProp("mdpDB"));

    PoolableConnectionFactory poolableConnectionFactory =
        new PoolableConnectionFactory(connectionFactory, null);

    ObjectPool<PoolableConnection> connectionPool =
        new GenericObjectPool<>(poolableConnectionFactory);

    poolableConnectionFactory.setPool(connectionPool);

    dataSource = new PoolingDataSource<>(connectionPool);
  }
}
