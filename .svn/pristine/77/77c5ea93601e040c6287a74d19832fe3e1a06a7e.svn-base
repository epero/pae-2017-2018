package dal.services;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.logging.Logger;
import javax.sql.DataSource;
import org.apache.commons.dbcp2.ConnectionFactory;
import org.apache.commons.dbcp2.DriverManagerConnectionFactory;
import org.apache.commons.dbcp2.PoolableConnection;
import org.apache.commons.dbcp2.PoolableConnectionFactory;
import org.apache.commons.dbcp2.PoolingDataSource;
import org.apache.commons.pool2.ObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPool;
import exceptions.FatalException;
import util.AppContext;
import util.AppContext.DependanceInjection;

class DalServicesImpl implements DalServices, DalBackendServices {

  @DependanceInjection
  private AppContext appContext;

  // private Connection conn = null;

  // TODO stocker en classe interne (optionnel)
  private ThreadLocal<Connection> connThrLoc = new ThreadLocal<>();
  // private ThreadLocal<Integer> comptTransThrLoc = new ThreadLocal<>();
  private DataSource dataSource = null;
  // private int compteurTransaction = 0;

  /*
   * private void connect() { if (conn != null) { return; } try {
   * Class.forName(appContext.getValueProp("driverClassName")); } catch (ClassNotFoundException ex)
   * { throw new FatalException("Driver Postgresql manquant !"); }
   * 
   * try { conn = DriverManager.getConnection(appContext.getValueProp("url"),
   * appContext.getValueProp("ndcDB"), appContext.getValueProp("mdpDB")); } catch (SQLException ex)
   * { throw new FatalException("Erreur de connexion à la base de données"); } }
   */

  private void connect() {
    if (dataSource == null) {
      setUpDataSource();
    }
    if (connThrLoc.get() == null) {
      try {
        connThrLoc.set(dataSource.getConnection());
        // comptTransThrLoc.set(0);
      } catch (SQLException ex) {
        throw new FatalException("Erreur de connexion à la base de données");
      }
    }
  }

  // verifier si setAutoCommit() puisse lancer une exception
  // si oui, il faut s'assurer qu'on puisse .close()
  private void freeConnection() {
    try {
      if (!connThrLoc.get().isClosed()) {
        try {
          connThrLoc.get().setAutoCommit(true);
        } catch (SQLException ex) {
          // ex.printStackTrace();
        }
        connThrLoc.get().close();
      }
    } catch (SQLException ex) {
      // connThrLoc.remove();
      throw new FatalException("Erreur de connexion à la base de données");
    } finally {
      connThrLoc.remove();
    }
    // connThrLoc.remove();

    // comptTransThrLoc.set(0);
  }

  @Override
  public void startTransaction() {
    connect();
    try {
      connThrLoc.get().setAutoCommit(false);
    } catch (SQLException ex) {
      freeConnection();
      throw new FatalException("Erreur dans la méthode startTransaction()");
    }

    /*
     * if (comptTransThrLoc.get() == 0) { try { connThrLoc.get().setAutoCommit(false); } catch
     * (SQLException ex) { ex.printStackTrace();
     * System.err.println("Erreur dans la méthode startTransaction()"); throw new
     * FatalException("Erreur base de données"); } }
     */
    // comptTransThrLoc.set(comptTransThrLoc.get() + 1);
    // System.out.println("startTransaction() - compteur incrémenté : " + comptTransThrLoc.get());

  }

  public void commitTransaction() {
    /*
     * if (comptTransThrLoc.get() == 0) { System.err
     * .println("Erreur dans la méthode commitTransaction() : le compteurTransaction == 0"); throw
     * new FatalException("Erreur base de données/ de programmation"); } if (comptTransThrLoc.get()
     * > 0) { comptTransThrLoc.set(comptTransThrLoc.get() - 1);
     * System.out.println("commitTransaction() - compteur décrémenté : " + comptTransThrLoc.get());
     * } if (comptTransThrLoc.get() == 0) {}
     */
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    try {
      connThrLoc.get().commit();
      freeConnection();
    } catch (SQLException ex) {
      Logger.getLogger("stagifyLogger").severe("Erreur SQL: " + ex.getStackTrace());
      rollback();
      // Faut-il lancer une fatalException? si oui il faut enlever le log
    }

  }

  @Override
  public void rollback() {
    // réinitialiser le compteur
    // compteurTransaction = 0;
    // System.out.println("rollback() - compteur réinitialisé : " + comptTransThrLoc.get());
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    try {
      connThrLoc.get().rollback();
    } catch (SQLException ex) {
      // ex.printStackTrace();
      // System.err.println("Erreur dans la méthode rollback()");
      freeConnection();
      throw new FatalException("Erreur base de données rollback()");
    } finally {
      // freeConnection();
    }
  }

  public PreparedStatement getPreparedStatement(String query) {
    // probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau
    // PreparedStatement --> couteux?
    // -> Bonne pratique avec PreparedStatement : les créer une seule fois (au démarrage ou au
    // premier usage)
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    PreparedStatement ps = null;
    try {
      ps = connThrLoc.get().prepareStatement(query);
    } catch (SQLException ex) {
      throw new FatalException("Impossible de récuperer le preparedStatement");
    }
    return ps;
  }

  public PreparedStatement getPreparedStatementForInsert(String query) {
    // probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau
    // PreparedStatement --> couteux?
    // -> Bonne pratique avec PreparedStatement : les créer une seule fois (au démarrage ou au
    // premier usage)
    if (connThrLoc.get() == null) {
      throw new FatalException("Erreur de programmation");
    }
    PreparedStatement ps = null;
    try {
      ps = connThrLoc.get().prepareStatement(query, Statement.RETURN_GENERATED_KEYS);
    } catch (SQLException ex) {
      throw new FatalException("Impossible de récuperer le preparedStatement");
    }
    return ps;
  }

  private void setUpDataSource() {
    if (dataSource != null) {
      return;
    }
    try {
      Class.forName(appContext.getValueProp("driverClassName"));
    } catch (ClassNotFoundException ex) {
      throw new FatalException("Driver Postgresql manquant !");
    }

    ConnectionFactory connectionFactory =
        new DriverManagerConnectionFactory(appContext.getValueProp("url"),
            appContext.getValueProp("ndcDB"), appContext.getValueProp("mdpDB"));

    PoolableConnectionFactory poolableConnectionFactory =
        new PoolableConnectionFactory(connectionFactory, null);

    ObjectPool<PoolableConnection> connectionPool =
        new GenericObjectPool<>(poolableConnectionFactory);

    poolableConnectionFactory.setPool(connectionPool);

    dataSource = new PoolingDataSource<>(connectionPool);
  }



  /**
   * Envoie de la requête en PreparedStatement à la base de données.
   * 
   * @param query Requête envoyée à la base de données
   * @return Une query préparée avec la string passée en paramètre
   * 
   */
  /*
   * public PreparedStatement getPreparedStatement(String query) { connect(); if (conn != null) { //
   * probleme: a chaque fois qu'on appelle la methode getPreparedStatement on crée un nouveau //
   * PreparedStatement --> couteux? // -> Bonne pratique avec PreparedStatement : les créer une
   * seule fois (au démarrage ou au // premier usage) PreparedStatement ps = null; try { ps =
   * conn.prepareStatement(query); } catch (SQLException ex) { throw new FatalException(
   * "Impossible de récuperer le preparedStatement"); } return ps; } throw new FatalException(
   * "Erreur de connexion à la base de données"); }
   */

  /*
   * @Override public void startTransaction() { connect(); if (compteurTransaction == 0) { try {
   * conn.setAutoCommit(false); } catch (SQLException ex) { ex.printStackTrace();
   * System.err.println("Erreur dans la méthode startTransaction()"); throw new FatalException(
   * "Erreur base de données"); } } compteurTransaction++; System.out.println(
   * "startTransaction() - compteur incrémenté : " + compteurTransaction);
   * 
   * }
   */

  /*
   * @Override public void commitTransaction() { if (compteurTransaction == 0) { System.err
   * .println("Erreur dans la méthode commitTransaction() : le compteurTransaction == 0"); throw new
   * FatalException("Erreur base de données"); } if (compteurTransaction > 0) {
   * compteurTransaction--; System.out.println("commitTransaction() - compteur décrémenté : " +
   * compteurTransaction); } if (compteurTransaction == 0) { try { conn.commit();
   * conn.setAutoCommit(true); } catch (SQLException ex) { ex.printStackTrace(); System.err.println(
   * "Erreur dans la méthode commitTransaction()"); rollback(); } } }
   */

  /*
   * @Override public void rollback() { // réinitialiser le compteur compteurTransaction = 0;
   * System.out.println("rollback() - compteur réinitialisé : " + compteurTransaction);
   * 
   * try { conn.rollback(); } catch (SQLException ex) { ex.printStackTrace(); System.err.println(
   * "Erreur dans la méthode rollback()"); throw new FatalException("Erreur base de données"); } }
   */
}
