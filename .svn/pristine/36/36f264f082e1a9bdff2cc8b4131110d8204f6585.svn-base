package util;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.List;
import exceptions.FatalException;

public class DaoUtil {

  /**
   * Méthode qui set un nombre arbitraire d'objets sur un PreparedStatement. La méthode itère sur
   * chaque objet passé en paramètre et appele la méthode setObject() sur le PreparedStatement.
   * 
   * @param ps, un PreparedStatement déjà créé
   * @param objects, un nombre arbitraire d'objets de type Object contenant l'input de l'utilisateur
   */
  public static void setPreparedStatement(PreparedStatement ps, Object... objects) {
    try {
      // le premier indice est à 1
      for (int i = 1; i <= objects.length; i++) {
        ps.setObject(i, objects[i - 1]);
      }
    } catch (SQLException ex) {
      throw new FatalException("Erreur lors de la customisation du preparedStatement");
    }
  }



  /**
   * Méthode qui : * vérifie s'il existe au moins un tuple pour un ResultSet et renvoie false le cas
   * contraire; * parcourt chaque tuple de ce ResultSet grace à un objet metadata. Pour chaque
   * tuple, la méthode : * récupère et renomme le nom de la colonne (un champ dans la BD) * recupère
   * par introspection les méthodes de la classe instanciée passée en paramètre. Pour chaque méthode
   * propres à l'instance, la méthode : * vérifie qu'il s'agit d'un setter et qu'il correspond au
   * nom de la colonne * set sur l'instance la valeur de la colonne du tuple en cours.
   * 
   * @param classe, une classe à instancier sur laquelle on invoque ses setters
   * @param rs, un ResultSet, résultat d'un preparedStatement.executeQuery()
   * @return List<Object>
   */
  public static List<Object> setResultSet(Class<?> classe, ResultSet rs) {
    try {
      ResultSetMetaData rsmd = rs.getMetaData(); // objet metadata
      List<Object> liste = new ArrayList<Object>();
      List<Method> setters = new ArrayList<Method>();
      if (rs.next()) {
        Object instance = classe.newInstance();
        for (Method method : classe.getDeclaredMethods()) {
          if (method.getName().startsWith("set")) {
            setters.add(method);
          }
        }
        do {
          instance = classe.newInstance();
          for (int i = 1; i <= rsmd.getColumnCount(); i++) {
            String nomColonne = rsmd.getColumnName(i).replace("_", "").toLowerCase();
            for (Method setter : setters) {
              if (nomColonne.equals(setter.getName().toLowerCase().substring(3))) {
                if (rs.getObject(i) == null) {
                  // passer à l'itération suivante
                  continue;
                }
                if (rs.getObject(i).getClass().getName().equals("java.sql.Timestamp")) {
                  Timestamp ts = (Timestamp) rs.getObject(i);
                  setter.invoke(instance, ts.toLocalDateTime().toLocalDate());
                } else {
                  setter.invoke(instance, rs.getObject(i));
                }
              }
            }
          }
          liste.add(instance);
          System.out.println(instance.toString());
        } while (rs.next());
      }
      return liste;

    } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException
        | SQLException | InstantiationException ex) {
      ex.printStackTrace();
      throw new FatalException("Erreur accès Db");
    }
  }
}
