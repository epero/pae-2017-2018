package util;

import java.text.SimpleDateFormat;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Map;
import org.mindrot.jbcrypt.BCrypt;
import com.owlike.genson.Genson;
import com.owlike.genson.GensonBuilder;
import exceptions.BizException;
import exceptions.FatalException;

public class Util {

  private static Genson genson =
      new GensonBuilder().useDateFormat(new SimpleDateFormat("dd-MM-yyyy")).create();

  private Util() {

  }

  /**
   * Extrait la date d'une chaîne de caractères JSON.
   * 
   * @param json Chaîne de caractères JSON
   * @param nomChampDate Nom de la clé JSON possédant la date
   * @return La date sous format LocalDate
   */
  public static LocalDate jsonToLocalDate(String json, String nomChampDate) {
    Map<String, Object> mapData = genson.deserialize(json, Map.class);
    DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
    String date = mapData.get(nomChampDate).toString();
    return LocalDate.parse(date, formatter);
  }

  public static void checkFormatString(String string, int maxCaracteres) throws BizException {
    if (string == null || string == "" || string.length() > maxCaracteres) {
      throw new BizException("Un des champs est incorrect");
    }
  }

  public static void checkFormatDate(LocalDate date) throws BizException {
    if (date == null) {
      throw new BizException("Un des champs est incorrect");
    }
  }

  public static void checkFormatTel(String tel, int maxCaracteres) throws BizException {
    checkFormatString(tel, maxCaracteres);
    if (!tel.matches("[0-9]+|\\+[0-9]+")) {
      throw new BizException("Un des champs est incorrect");
    }
  }

  public static void checkFormatEmail(String email, int maxCaracteres) throws BizException {
    checkFormatString(email, maxCaracteres);
    if (!email.matches(".+@.*vinci\\..+")) {
      throw new BizException("Un des champs est incorrect");
    }
  }

  /**
   * Vérifie si l'objet n'est pas nul.
   * 
   * @param ob Objet à vérifier
   */
  public static void checkObject(Object ob) {
    if (ob == null) {
      throw new FatalException("");
    }
  }

  /**
   * Vérifie si la chaîne est non vide et non nul.
   * 
   * @param st Chaîne à vérifier
   * @throws BizException
   */
  public static void checkString(String st) {
    checkObject(st);
    if (st.matches("\\s*")) {
      throw new FatalException("Erreur de programmation");
    }
  }

  /**
   * Vérifie si la chaîne est convertible en nombre.
   * 
   * @param st Chaîne à vérifier
   * @throws BizException
   */
  public static void checkNumerique(String st) throws BizException {
    checkString(st);
    try {
      Long.parseLong(st);
    } catch (NumberFormatException ex) {
      throw new BizException("");
    }
  }

  /**
   * Vérifie si le nombre est positif ou égal à zéro.
   * 
   * @param nombre Nombre à vérifier
   * @throws BizException
   */
  public static void checkPositiveOrZero(double nombre) throws BizException {
    if (nombre < 0) {
      throw new BizException("");
    }
  }

  /**
   * Vérifie si le nombre est strictement positif.
   * 
   * @param nombre Nombre à vérifier
   * @throws BizException
   */
  public static void checkPositive(double nombre) throws BizException {
    if (nombre <= 0) {
      throw new BizException("");
    }
  }

  /**
   * Crypte la chaîne passée en paramètre avec le sel définit.
   * 
   * @param mdp Chaîne à crypter
   * @return La chaîne cryptée
   */
  public static String hashpw(String mdp) {
    return BCrypt.hashpw(mdp, BCrypt.gensalt());
  }

  /**
   * Vérifie si les deux chaînes sont les mêmes.
   * 
   * @param mdp Chaîne non cryptée à comparer
   * @param mdpHashed Chaîne cryptée à comparer
   * @return True si les chaînes sont identiques, false sinon
   */
  public static boolean checkpw(String mdp, String mdpHashed) {
    return BCrypt.checkpw(mdp, mdpHashed);
  }
}
