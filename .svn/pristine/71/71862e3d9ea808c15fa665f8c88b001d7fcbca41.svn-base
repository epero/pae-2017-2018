package util;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Properties;
import java.util.logging.Logger;
import exceptions.FatalException;


public class AppContext {

  private HashMap<Class<?>, Object> instances = new HashMap<Class<?>, Object>();

  private Properties properties;

  static Logger monLog = Logger.getLogger("stagifyLogger");

  @Retention(RetentionPolicy.RUNTIME)
  public @interface DependanceInjection {
  }

  /**
   * Constructeur.
   */
  public AppContext() {
    try {
      instances.put(Class.forName("util.AppContext"), this);
    } catch (ClassNotFoundException ex) {
      monLog.severe("impossible de charger AppContext");
      // ex.printStackTrace();
      // System.out.println("Impossible de charger AppContext");
      throw new FatalException();
    }
  }

  /**
   * Crée une nouvelle instance de l'objet en paramètre via l'injection dépendance.
   * 
   * @param objet à instancier
   */
  public void recurDepInj(Object objet) {
    if (properties == null) {
      monLog.warning("Le fichier properties n'a pas encore été chargé");
      // System.out.println("Le fichier properties n'a pas encore été chargé");
      return;
    }
    for (Field field : objet.getClass().getDeclaredFields()) {
      if (field.isAnnotationPresent(DependanceInjection.class)) {
        Object ob;
        Class<?> cl;
        try {
          cl = Class.forName(properties.getProperty(field.getType().getCanonicalName()));
        } catch (ClassNotFoundException e1) {
          monLog.severe("Classe inexistante");
          // System.out.println("Classe inexistante");
          // e1.printStackTrace();
          throw new FatalException();
        }
        if (!instances.containsKey(cl)) {
          System.out.println(field.getType().getCanonicalName());
          Constructor constructor;
          try {
            constructor = cl.getDeclaredConstructor();
          } catch (NoSuchMethodException | SecurityException ex) {
            monLog.severe("Constructeur inexistant");
            // System.out.println("Constructeur inexistant");
            // ex.printStackTrace();
            throw new FatalException();
          }
          constructor.setAccessible(true);
          try {
            ob = constructor.newInstance();
          } catch (InstantiationException | IllegalAccessException | IllegalArgumentException
              | InvocationTargetException ex) {
            monLog.severe("Initialisation impossible");
            // System.out.println("Initialisation impossible");
            // ex.printStackTrace();
            throw new FatalException();
          }
          instances.put(cl, ob);
          // appel récursif
          recurDepInj(ob);
        }

        field.setAccessible(true);
        try {
          field.set(objet, instances.get(cl));
        } catch (IllegalArgumentException | IllegalAccessException ex) {
          // ex.printStackTrace();
          monLog.severe("récupération instance impossible");
          throw new FatalException();
        }
      }
    }
  }


  /**
   * Charge le fichier Properties passé en paramètre.
   * 
   * @param fichier Le fichier où se trouve les Properties
   */
  public void loadProps(String fichier) {
    if (fichier == null) {
      monLog.info("run du fichier properties par défaut (dev.properties)");
      // System.out.println("run du fichier par defaut");
      fichier = "dev.properties";
    }
    properties = new Properties();

    try (FileInputStream file = new FileInputStream("conf/" + fichier)) {
      properties.load(file);
    } catch (FileNotFoundException ex) {
      monLog.severe("Fichier properties introuvable");
      // System.out.println("Fichier properties introuvable");
      // ex.printStackTrace();
      throw new FatalException();
    } catch (IOException ex) {
      monLog.severe("Impossible de lire le fichier properties");
      // System.out.println("Impossible de lire le fichier");
      // ex.printStackTrace();
      throw new FatalException();
    }
  }


  /**
   * Cherche la clé associée à la chaîne passée en paramètre.
   * 
   * @param key la chaîne représentant la clé
   * @return la clé correspondante dans le fichier Properties
   */
  public String getValueProp(String key) {
    if (properties == null) {
      monLog.warning("Le fichier properties n'a pas encore été chargé");
      // System.out.println("Le fichier properties n'a pas encore été chargé");
      return null;
    }
    Util.checkString(key);
    return properties.getProperty(key);
  }
}

